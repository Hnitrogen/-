【完全背包问题】

综合起来 f[i][j] = f[i-1,j-k*v[i]] + k*w[i] 

【朴素】
	for(int i = 1 ; i <= n ; i++)
		for(int j = 0 ; j <= m ; j++)
			for(int k = 0 ; k*v[i] <= j ; k++)
				f[i][j] = max(f[i][j] , f[i-1][j-k*v[i]] + k*w[i]) ;
	cout << f[n][m] << endl ;


【优化】
	f[i][j] = max f[i-1,j] 		f[i-1,j-v]+w f[i-1,j-2v]+2w .... 
	f[i][j-v] = max 			f[i-1][j-v]  f[i-1][j-2v]+2w  f[i-1][j-3v]+3w
	                            [每一项都比对应的多了一个 w ] 	

	综上 f[i][j] = max(f[i-1][j] , f[i][j-v]+w) 
	
这样参考01背包的写法

	for(int i = 1 ; i <= n ; i++)
		for(int j = 0 ; j <=m ; j++)
		{												
			f[i][j] = f[i-1][j] ;         //【01背包】f[i-1][j-v[i]] + w[i] 这点不同 
			if(j >= v[i])	f[i][j] = max(f[i][j] , f[i][j-v[i]] + w[i]) ; 
		}

【再次优化】  (和01背包同理)
	去掉f[i]这一维 , 删去恒等式 , 更改j去掉if判断

	for(int i = 1 ; i <= n ; i++)
		for(int j = v[i] ; j <= m ; j++)
			f[j] = max (f[j] , f[j-v[i]] + w[i] ) 
		cout << f[m] << endl ;

【滑动窗口最大值需要用单调队列去优化】


【多重背包问题】	每件物品有si件 , 而不是无限件
	

						集合   所以只从前i个物品中选,且体积不超过j的选法
			状态表示 
						属性	   Max

动态规划 


			状态计算   f[i][j] = max f[i-1][j-k*v[i]] + k*w[i]  k从0到si

【朴素】


	for(int i = 1 ; i <= n ; i++)
		for(int j = 0 ; j <= m ; j++)
			for(int k = 0 ; k <= s[i] && k*v[i] <= j ; k++)
					f[i][j] = max(f[i][j] , f[i-1][j-k*v[i]] + k*w[i]) ;

【二进制优化】

	数量用二进制组合表示,然后做01背包


【分组背包问题】		每个组中只能选一个



						集合   所以只从前i个物品中选,且体积不超过j的选法
			状态表示 
						属性	   Max

动态规划 


			状态计算(集合划分)	因为只能选一件

			f[i-1][j] , f[i-1][j-v[i,k]] + w[i,k] 
								//从第i组物品中选第k个物品


就做个01背包而已





