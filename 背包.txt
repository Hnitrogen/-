动态规划									


【01背包问题】		每个物品最多选一件


											所有选法 
								 集合  			 
	状态表示		怎么表示  fij     			 1  只从前i个物品中去选 
										条件  
											 2  总体积小于j1

								 属性   存价值的最大值
										

										
									【dp问题的优化 --> 怎么降维 （要从朴素的开始考虑) 】 

	状态计算		怎么算出来	: 某个状态如何从别的状态过来  (集合划分)
							  将fij这个集合(所有选法) 用子集表示

							  	1   不含i个物品	 --> 从1~i-1中选,且总体积不超过j  --> f[i-1][j]	【一定存在】

							  	2	含i个物品     --> 从1~i中选,包含i且总体积不超过j
							  					【曲线救国】 --> 从1~i-1选 且总体积不超过 j-v[i]	 	【当j >= v[i] 才存在 】	    
							  					--> f[i-1][j-v[i]] 

				最终答案就是两个集合里的最大值 max( f[i-1][j] , f[i-1][j-v[i]] ) ;			  
 
【代码】
	for(int i = 1 ; i <= n ; i++)
		for(int j = 0 ; j <= m ; j++)	//体积
		{
			f[i][j] = f[i-1][j] ;		// 1 
			if(j >= v[i])	f[i][j] = max(f[i][j] , f[i-1][j-v[i]] + w[i])  // 2
		}

【优化】
	f[i][j] = f[i-1][j] --> f[j] = f[j]   // 恒成立(删去)

	if(j >= v[i])	--> for(int j = v[i] ; j <= m ; j++)  --> 去掉if判断 (因为if恒成立)

	f[j] = max(f[j] , f[j-v[i]] + w[i])   !=  因为 f[i-1][j-v[i]]  != f[j-v[i]]  ( f[i][j-v[i]] )

	如果 f[i-1][j-v[i]] 不存在(还没被更新) 那么 f[i][j-v[i]] == f[j-v[i]] 
	一维里面 当前状态是由前一个状态推到的 --> 如果我转换顺序
	让背包体积逆序去枚举 , 那么前一个状态就还没被确定 ， 所以不会污染 , f[i][j-v[i]] == f[i-1][j-v[i]] 就可以最终优化成

	for(int i = 1 ; i <= n ; i++)
		for(int j = m ; j >= v[i] ; j--)
			f[j] = max(f[j] , f[j-v[i]] + w[i]) ;



【完全背包问题】	 每件物品由无限个


					集合   只考虑前i个物品,且体积不超过j
		状态表示		
					属性   max


		状态计算		集合的划分   0...1...2...3...k-1...k : 第i个物品选了 0、1、2、...k 个 
					
					1 第i个物品选了0个  f[i-1][j]

					2 【曲线救国】	 先求去掉k个i的最大值
								 求max -> f[i-1][j-k*v[i]]
								 再加回来 f[i-1][j-k*v[i]] + k*w[i]

					综合 0~k -> f[i][j] = f[i-1][j-k*v[i]] + k*w[i]



【完全背包问题】

综合起来 f[i][j] = f[i-1,j-k*v[i]] + k*w[i] 

【朴素】
	for(int i = 1 ; i <= n ; i++)
		for(int j = 0 ; j <= m ; j++)
			for(int k = 0 ; k*v[i] <= j ; k++)
				f[i][j] = max(f[i][j] , f[i-1][j-k*v[i]] + k*w[i]) ;
	cout << f[n][m] << endl ;


【优化】
	f[i][j] = max f[i-1,j] 		f[i-1,j-v]+w f[i-1,j-2v]+2w .... 
	f[i][j-v] = max 			f[i-1][j-v]  f[i-1][j-2v]+w  f[i-1][j-3v]+2w
	                            [每一项都比对应的多了一个 w ] 	

	综上 f[i][j] = max(f[i-1][j] , f[i][j-v]+w) 
	
这样参考01背包的写法

	for(int i = 1 ; i <= n ; i++)
		for(int j = 0 ; j <=m ; j++)
		{												
			f[i][j] = f[i-1][j] ;         //【01背包】f[i-1][j-v[i]] + w[i] 这点不同 
			if(j >= v[i])	f[i][j] = max(f[i][j] , f[i][j-v[i]] + w[i]) ; 
		}

【再次优化】  (和01背包同理)
	去掉f[i]这一维 , 删去恒等式 , 更改j去掉if判断

	for(int i = 1 ; i <= n ; i++)
		for(int j = v[i] ; j <= m ; j++)
			f[j] = max (f[j] , f[j-v[i]] + w[i] ) 
		cout << f[m] << endl ;

【滑动窗口最大值需要用单调队列去优化】


【多重背包问题】	每件物品有si件 , 而不是无限件
	

						集合   所以只从前i个物品中选,且体积不超过j的选法
			状态表示 
						属性	   Max

动态规划 


			状态计算   f[i][j] = max f[i-1][j-k*v[i]] + k*w[i]  k从0到si

【朴素】


	for(int i = 1 ; i <= n ; i++)
		for(int j = 0 ; j <= m ; j++)
			for(int k = 0 ; k <= s[i] && k*v[i] <= j ; k++)
					f[i][j] = max(f[i][j] , f[i-1][j-k*v[i]] + k*w[i]) ;

【二进制优化】

	数量用二进制组合表示,然后做01背包


【分组背包问题】		每个组中只能选一个



						集合   所以只从前i个物品中选,且体积不超过j的选法
			状态表示 
						属性	   Max

动态规划 


			状态计算(集合划分)	因为只能选一件

			f[i-1][j] , f[i-1][j-v[i,k]] + w[i,k] 
								//从第i组物品中选第k个物品


就做个01背包而已




